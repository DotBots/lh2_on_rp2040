import numpy as np
import itertools

def gen_checkpoints(num_poly=0, subsearch_sections=2**6):
    # Convert hex character to 4-bit binary string
    hex_to_bits = {
        '0': [0,0,0,0], '1': [0,0,0,1], '2': [0,0,1,0], '3': [0,0,1,1],
        '4': [0,1,0,0], '5': [0,1,0,1], '6': [0,1,1,0], '7': [0,1,1,1],
        '8': [1,0,0,0], '9': [1,0,0,1], 'A': [1,0,1,0], 'B': [1,0,1,1],
        'C': [1,1,0,0], 'D': [1,1,0,1], 'E': [1,1,1,0], 'F': [1,1,1,1]
    }

    # Define polynomials (same as MATLAB input)
    polynomials = [
        '0001D258','00017E04','0001FF6B','00013F67','0001B9EE','000198D1',
        '000178C7','00018A55','00015777','0001D911','00015769','0001991F',
        '00012BD0','0001CF73','0001365D','000197F5','000194A0','0001B279',
        '00013A34','0001AE41','000180D4','00017891','00012E64','00017C72',
        '00019C6D','00013F32','0001AE14','00014E76','00013C97','000130CB',
        '00013750','0001CB8D'
    ]

    # Convert all polynomials to binary bits
    polybits = np.zeros((32, 32), dtype=int)
    for jj, hex_str in enumerate(polynomials):
        for kk, char in enumerate(hex_str):
            polybits[jj, (kk * 4):(kk + 1) * 4] = hex_to_bits[char]

    # Select polynomial and truncate to 17 bits (remove first 15 bits)
    selected_poly = polybits[num_poly, 15:32]  # Keep last 17 bits

    # Generate LFSR sequence
    sequence_length = 131071  # 2^17 - 1
    poly_brute = np.zeros(sequence_length, dtype=int)
    state = np.array([0] * 16 + [1], dtype=int)  # Initial state: 16 zeros + 1
    poly_brute[:17] = state[::-1]  # Store initial state reversed

    for i in range(17, sequence_length):
        feedback = np.sum(state * selected_poly) % 2
        state = np.roll(state, -1)
        state[-1] = feedback
        poly_brute[i] = feedback

    # Generate checkpoints
    indices = np.round(np.linspace(0, 2**17, subsearch_sections + 1)).astype(int)
    sequences = []
    for i in range(1,subsearch_sections): # Ignore the first element, because that's just index zero
        start = indices[i] - 1  # This -1 makes the the python indices match the old matlab script indices.
        end = start + 16
        bits = poly_brute[start:end + 1]
        bit_str = ''.join(map(str, bits))
        sequences.append(bit_str)

    # Print results
    print(f"\\brief: Finds the position of a 17-bit sequence (bits) in the sequence generated by polynomial {num_poly} with initial seed 1")
    print("    [")
    print(f"        # p{num_poly}")
    for idx, seq in enumerate(sequences, 1):
        print(f"    0b{seq},  # {idx}/{subsearch_sections}")
    print("    ],")

def gen_full_lfsr_sequence(num_poly=0):
    # Convert hex character to 4-bit binary string
    hex_to_bits = {
        '0': [0,0,0,0], '1': [0,0,0,1], '2': [0,0,1,0], '3': [0,0,1,1],
        '4': [0,1,0,0], '5': [0,1,0,1], '6': [0,1,1,0], '7': [0,1,1,1],
        '8': [1,0,0,0], '9': [1,0,0,1], 'A': [1,0,1,0], 'B': [1,0,1,1],
        'C': [1,1,0,0], 'D': [1,1,0,1], 'E': [1,1,1,0], 'F': [1,1,1,1]
    }

    # Define polynomials (same as MATLAB input)
    polynomials = [
        '0001D258','00017E04','0001FF6B','00013F67','0001B9EE','000198D1',
        '000178C7','00018A55','00015777','0001D911','00015769','0001991F',
        '00012BD0','0001CF73','0001365D','000197F5','000194A0','0001B279',
        '00013A34','0001AE41','000180D4','00017891','00012E64','00017C72',
        '00019C6D','00013F32','0001AE14','00014E76','00013C97','000130CB',
        '00013750','0001CB8D'
    ]

    # Convert all polynomials to binary bits
    polybits = np.zeros((32, 32), dtype=int)
    for jj, hex_str in enumerate(polynomials):
        for kk, char in enumerate(hex_str):
            polybits[jj, (kk * 4):(kk + 1) * 4] = hex_to_bits[char]

    # Select polynomial and truncate to 17 bits (remove first 15 bits)
    selected_poly = polybits[num_poly, 15:32]  # Keep last 17 bits

    # Generate LFSR sequence
    sequence_length = 131071  # 2^17 - 1
    poly_brute = np.zeros(sequence_length, dtype=int)
    state = np.array([0] * 16 + [1], dtype=int)  # Initial state: 16 zeros + 1
    poly_brute[:17] = state[::-1]  # Store initial state reversed

    for i in range(17, sequence_length):
        feedback = np.sum(state * selected_poly) % 2
        state = np.roll(state, -1)
        state[-1] = feedback
        poly_brute[i] = feedback

    return poly_brute

def naive_checkpoints_indices(num_of_checkpoints):
    # Return a list of indices for regularly spaced checkpoints
    # indices = np.round(np.linspace(0, 2**17, num_of_checkpoints + 1)).astype(int)[0:-1]
    indices = np.round(np.linspace(0, 110e3, num_of_checkpoints + 1)).astype(int)[0:-1]
    indices[0] += 1  # Make sure the first element is 1 and not 0
    return indices

def check_hash_collisions(lfsr_sequence, indices, hash_size):
    # returns a list of lists. each list contains indices of checkpoints whose hash collides
    # Ex. [[2,3],[,1,4,5]] this means checkpoint 2 and 3 collide, and 1, 4, and 5 collides.

    start = indices.reshape((-1,)) -1
    stop = indices.reshape((-1,)) + 16

    sequences = np.zeros((indices.shape[0],17)).astype(int)

    for i in range(indices.shape[0]):
        sequences[i] = lfsr_sequence[start[i]:stop[i]]

    # Get the Hash
    hashes = sequences[:,:hash_size]

    # check for repeated rows
    unique_rows = np.unique(hashes, axis=0)
    return len(unique_rows) < len(hashes)

    sequence_dict = {}

    # Get the lfsr value for the checkpoint
    for index in indices: # Ignore the first element, because that's just index zero
        start = index - 1  # This -1 makes the the python indices match the old matlab script indices.
        end = start + 16
        bits = lfsr_sequence[start:end + 1]
        bit_str = ''.join(map(str, bits))
        sequence_dict[index] = bit_str
    
    # Get the hash
    hash_dict = {}
    for check, bits in sequence_dict.items():
        hash_dict[check] = bits[0:hash_size]

    # Check for collisions
    # Make a list of the hashes
    hash_list = [ hash_dict[k] for k in hash_dict]
    for idx,hash in enumerate(hash_list):
        if hash in hash_list[idx+1:]:
            return True

    # If no one matches, then there are no collision
    return False

def create_offset_matrix(lfsr_sequence, indices, hash_bits):
    "Returns a matrix. each line is an checkpoint index, and each column is the offest needed to arrive at a particular hash"

    offset_matrix = np.ones((indices.shape[0], 2**hash_bits)).astype(int)
    paint_value = 2**(hash_bits+1) * 10
    offset_matrix *= paint_value # paint the matrix with an arbitrarily large number

    max_offset = 2**(hash_bits+1) # From where to where to check the lfsr sequence

    # Go checkpoint by checkpoint
    for idx,checkpoint in enumerate(indices):

        # If this is the first checkpoint, enforce only positive offsets
        if checkpoint == 1:
            offset_bot = 0
            offset_top = 2*max_offset
        else:
            offset_bot = -max_offset
            offset_top = max_offset

        # check many lfsr positions before and after the checkpoint
        for offset in range(offset_bot, offset_top):

            # extract current lfsr section
            start = checkpoint -1  + offset
            stop = checkpoint + 16 + offset
            lfsr_chunk = lfsr_sequence[start:stop]

            # compute hash
            hash = lfsr_chunk[:hash_bits]
            # convert the hash array into an actual unsigned integer
            hash_int = np.dot(hash,1 << np.arange(len(hash) - 1, -1, -1)) 

            # save the value to the offset matrix if there is not an smaller value already present
            if abs(offset) < abs(offset_matrix[idx][hash_int]):
                offset_matrix[idx][hash_int] = offset

    return offset_matrix

def find_min_offsets(offset_matrix, indices, hash_bits):

    # start the variables for the random optimizator
    print_n = 0
    best_candidate = 0
    best_kpi = 2**hash_bits *10

    # Set the seed for the simulation
    # np.random.seed(42)
    np.random.seed(40)
    # np.random.seed(50)

    # Precreate the row index
    row_idx = np.arange(offset_matrix.shape[0])

    while(True):
        # Sample a new random index for the offset matrix
        sample = np.random.permutation(offset_matrix.shape[1])[:offset_matrix.shape[0]]  # sample, and remove one if tha matrix is not square, because the offset matrix is (63,64)
        # Get the vector of candidate offsets
        candidate = offset_matrix[row_idx,sample]

        # if the proposed offset for the first checkpoint (0x001) is negative, discard the solution
        # We are only interested in positive offsets for the first checkpoint.
        # if candidate[0] < 0: continue

        # Evaluate the solution
        if np.abs(candidate).max() < best_kpi:
            best_kpi = np.abs(candidate).max()
            best_candidate = candidate

        # Print progress every once in a while
        print_n += 1
        if print_n % 50000 == 0:
            print(f"{best_kpi} = {best_candidate}")

        # Stop if you hit a miracle
        if best_kpi <= 50: break

    return best_candidate

def indices_2_lfsr(full_lfsr, indices, hash_bits):

    start = indices.reshape((-1,)) -1
    stop = indices.reshape((-1,)) + 16

    sequences = np.zeros((indices.shape[0],17)).astype(int)

    for i in range(indices.shape[0]):
        sequences[i] = full_lfsr[start[i]:stop[i]]

    # Get the Hash
    hashes = sequences[:,:hash_bits]
    hashes_int = np.dot(hashes,1 << np.arange(hashes.shape[1] - 1, -1, -1))

    return sequences, hashes_int

def print_c_tables(indices, lfsr, hashes):

    pass    

def gen_checkpoints_2(num_poly=0, hash_bits=6):

    num_checkpoints = 2**hash_bits
    full_lfsr = gen_full_lfsr_sequence(num_poly)
    naive_indices = naive_checkpoints_indices(num_checkpoints)

    # Compute the matrix of lfsr hash offset
    offset_matrix = create_offset_matrix(full_lfsr, naive_indices, hash_bits)
    # Find the best combination of offsets
    offset_vector = find_min_offsets(offset_matrix, naive_indices, hash_bits)

    # Apply the offsets:
    optimal_indices = naive_indices + offset_vector

    # Get the lfsr section for the optimal checkpoints
    optimal_lfsr, optimal_hash  = indices_2_lfsr(full_lfsr, optimal_indices, hash_bits) 
    naive_lfsr, naive_hash  = indices_2_lfsr(full_lfsr, naive_indices, hash_bits) 

    print(optimal_indices)
    print(optimal_hash)
    print(offset_vector)
    print(naive_indices)

    return boop



if __name__ == "__main__":

    boop = gen_checkpoints_2(num_poly=0, hash_bits=6)