%% generate c code to do "fast" polynomial search
%  parameters:

clc;
num_poly = 0; % select the polynomial for which the function should be generated (accepted values [0:31])
subsearch_sections = 2^6; % select the number of pieces that the search should be broken into, please only use 2^N N<17

%% Polynomial and bitstream generation:
%  get the polynomials from the internet
%  the relevant bits of the polynomials are in the vector "polybits"
polynomials = [ '0001D258','00017E04', ...
               '0001FF6B','00013F67', ...
               '0001B9EE','000198D1', ...
               '000178C7','00018A55', ...
               '00015777','0001D911', ...
               '00015769','0001991F', ...
               '00012BD0','0001CF73', ...
               '0001365D','000197F5', ...
               '000194A0','0001B279', ...
               '00013A34','0001AE41', ...
               '000180D4','00017891', ...
               '00012E64','00017C72', ...
               '00019C6D','00013F32', ...
               '0001AE14','00014E76', ...
               '00013C97','000130CB', ...
               '00013750','0001CB8D'];

for jj = 0:31
    p{jj+1} = polynomials(jj*8+1:(jj+1)*8);
end

polybits = zeros(32,32);
for jj = 1:32
    tempstring = p{jj};
    for kk = 1:8
        if tempstring(kk) == '0'
            polybits((kk-1)*4+1:4*kk,jj) = [0,0,0,0];
        end
        if tempstring(kk) == '1'
            polybits((kk-1)*4+1:4*kk,jj) = [0,0,0,1];
        end
        if tempstring(kk) == '2'
            polybits((kk-1)*4+1:4*kk,jj) = [0,0,1,0];
        end
        if tempstring(kk) == '3'
            polybits((kk-1)*4+1:4*kk,jj) = [0,0,1,1];
        end
        if tempstring(kk) == '4'
            polybits((kk-1)*4+1:4*kk,jj) = [0,1,0,0];
        end
        if tempstring(kk) == '5'
            polybits((kk-1)*4+1:4*kk,jj) = [0,1,0,1];
        end
        if tempstring(kk) == '6'
            polybits((kk-1)*4+1:4*kk,jj) = [0,1,1,0];
        end
        if tempstring(kk) == '7'
            polybits((kk-1)*4+1:4*kk,jj) = [0,1,1,1];
        end
        if tempstring(kk) == '8'
            polybits((kk-1)*4+1:4*kk,jj) = [1,0,0,0];
        end
        if tempstring(kk) == '9'
            polybits((kk-1)*4+1:4*kk,jj) = [1,0,0,1];
        end
        if tempstring(kk) == 'A'
            polybits((kk-1)*4+1:4*kk,jj) = [1,0,1,0];
        end
        if tempstring(kk) == 'B'
            polybits((kk-1)*4+1:4*kk,jj) = [1,0,1,1];
        end
        if tempstring(kk) == 'C'
            polybits((kk-1)*4+1:4*kk,jj) = [1,1,0,0];
        end
        if tempstring(kk) == 'D'
            polybits((kk-1)*4+1:4*kk,jj) = [1,1,0,1];
        end
        if tempstring(kk) == 'E'
            polybits((kk-1)*4+1:4*kk,jj) = [1,1,1,0];
        end
        if tempstring(kk) == 'F'
            polybits((kk-1)*4+1:4*kk,jj) = [1,1,1,1];
        end
    end
end
polybits(1:15,:) = [];

poly = polybits(:,num_poly+1);
poly_in_str_form = num2str(poly');
poly_in_str_form(poly_in_str_form==' ')='';

%  generate the entire 2^17 bit LFSR sequence
poly_brute = zeros(131071,1);
state = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1];
poly_brute(1:17) = fliplr(state);
feedback_bit = 0;
for i = 18:length(poly_brute)
    feedback_bit = mod(sum(state.*poly'),2);
    state = circshift(state,-1);
    state(end) = feedback_bit;
    poly_brute(i) = feedback_bit;
end

%% find the 17-bit sequences at the locations
indices = linspace(0,2^17,subsearch_sections+1);
for i = 1:subsearch_sections-1
    bits_in_str_form = num2str(poly_brute(indices(i+1):indices(i+1)+16)');
    bits_in_str_form(bits_in_str_form==' ') = '';
    disp(strcat(num2str(indices(i+1)),'->',num2str(poly_brute(indices(i+1):indices(i+1)+16)')))
    # disp(indices(i+1))
    # disp()
    # disp(poly_brute(indices(i+1):indices(i+1)+16))


    sequence{i} = bits_in_str_form;
end

%% write the function
%  at the moment, this is printed to the command window
%  it can be copy-pasted into C from there

disp('/**')
disp(strcat('\brief: finds the position of a 17-bit sequence (bits) in the sequence generated by polynomial ',num2str(num_poly),' with initial seed 1'))
disp('\param bits: 17-bit sequence')
disp('\return count: location of the sequence')
disp('    ')

# disp('    [')
# disp(strcat('        # p',num2str(num_poly)))
# for i = 1:subsearch_sections-1
#     disp(strcat('    0b',sequence{i},',  # ',num2str(i),'/',num2str(subsearch_sections)))
# end
# disp('    ],')
